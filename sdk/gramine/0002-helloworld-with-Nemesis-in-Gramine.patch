diff --git a/CI-Examples/helloworld/helloworld.manifest.template b/CI-Examples/helloworld/helloworld.manifest.template
index 64c908e1..205860da 100644
--- a/CI-Examples/helloworld/helloworld.manifest.template
+++ b/CI-Examples/helloworld/helloworld.manifest.template
@@ -6,6 +6,9 @@ loader.log_level = "{{ log_level }}"
 
 loader.env.LD_LIBRARY_PATH = "/lib"
 
+loader.insecure__use_cmdline_argv = true
+loader.insecure__disable_aslr = true
+
 fs.mounts = [
   { path = "/lib", uri = "file:{{ gramine.runtimedir() }}" },
   { path = "/helloworld", uri = "file:helloworld" },
@@ -13,6 +16,8 @@ fs.mounts = [
 
 sgx.debug = true
 sgx.nonpie_binary = true
+sgx.preheat_enclave = true
+sgx.thread_num = 4
 
 sgx.trusted_files = [
   "file:{{ gramine.libos }}",
diff --git a/pal/src/host/linux-sgx/host_ecalls.c b/pal/src/host/linux-sgx/host_ecalls.c
index 201a0a27..f97ea21b 100644
--- a/pal/src/host/linux-sgx/host_ecalls.c
+++ b/pal/src/host/linux-sgx/host_ecalls.c
@@ -6,6 +6,185 @@
 #include "pal_ecall_types.h"
 #include "pal_rpc_queue.h"
 
+
+#define  SGX_STEP_ENABLE        1
+
+/*****************************************************************************/
+#if SGX_STEP_ENABLE
+    #include <signal.h>
+    #include <unistd.h>
+    #include <sys/mman.h>
+    #include "libsgxstep/apic.h"
+    #include "libsgxstep/pt.h"
+    #include "libsgxstep/debug.h"
+    #include "libsgxstep/enclave.h"
+    #include "libsgxstep/sched.h"
+    #include "libsgxstep/config.h"
+    #include "libsgxstep/idt.h"
+    #include "libsgxstep/cpu.h"
+    #include "libsgxstep/gdt.h"
+
+    #define  THREAD_END              4
+
+    #ifndef NUM_RUNS
+        #define NUM_RUNS                500
+    #endif
+
+    void fault_handler(int signal);
+    void attacker_config_runtime(void);
+    void attacker_config_page_table(void);
+    void aep_cb_func(void);
+
+    static spinlock_t g_step_lock = INIT_SPINLOCK_UNLOCKED;
+
+    static int thread_ctr = 0;
+
+    uint64_t *pte_encl;
+    uint64_t *pmd_encl;
+    uint64_t *code_adrs;
+    uint64_t erip_prev = 0x0;
+
+    /*
+     *  This are the start and end offsets of the function main() in the helloworld CI-Example.
+     *  You can find these in the compiled binary using objdump.
+     */
+    const uint64_t main_start_offset = 0x1149;
+    const uint64_t main_end_offset = 0x116e;
+
+    /*
+     * This is the address of the libos in the enclave. You can find this value by executing the
+     * binary with Gramine in DEBUG mode. Note that ASLR must be turned off in the manifest for
+     * the addresses to remain constant.
+     */
+    const uint64_t libos = 0xfd2b000;
+    /*
+     * This is the address in the enclave where the binary starts. Gramine will also tell you this
+     * offset in DEBUG mode.
+     */
+    const uint64_t bin_offset = 0xfc84000;
+
+    int irq_cnt = 0, do_irq = 1, reset_fault_handler = 0;
+    idt_t idt = {0};
+
+    int ignored_fault_cnt = 0;
+    int fault_cnt = 0;
+
+    /* Called upon SIGSEGV caused by untrusted page tables. */
+    void fault_handler(int signal)
+    {
+        ASSERT(fault_cnt++ < 10);
+        switch ( signal )
+        {
+            case SIGSEGV:
+                info("Caught fault %d! Restoring enclave page permissions..", signal);
+		        //info("Fault count: %d", fault_cnt);
+		        *pte_encl = MARK_NOT_EXECUTE_DISABLE(*pte_encl);
+                *pte_encl = MARK_NOT_ACCESSED(*pte_encl);
+                break;
+            default:
+                info("Caught unknown signal '%d'", signal);
+                //abort();
+        }
+
+        // NOTE: return eventually continues at aep_cb_func and initiates
+        // single-stepping mode.
+    }
+
+    void attacker_config_runtime(void)
+    {
+        ASSERT( !claim_cpu(VICTIM_CPU) );
+        ASSERT( !prepare_system_for_benchmark(PSTATE_PCT) );
+        ASSERT(signal(SIGSEGV, fault_handler) != SIG_ERR);
+        print_system_settings();
+        register_enclave_info();
+        print_enclave_info();
+    }
+
+    void aep_cb_func(void)
+    {
+        uint64_t erip = edbgrd_erip() - (uint64_t) get_enclave_base();
+
+        if(erip >= libos){
+            /* NOTE: we only want to step through the loaded binary */
+            //info("Ignoring RIP");
+            ignored_fault_cnt++;
+            return;
+        }
+
+        /**
+         * We only log instructions that are within the offset of the function we are interested in.
+         * For the helloworld example, this is the function main().
+         */
+        if(erip_prev >= (bin_offset + main_start_offset) && erip_prev <= (bin_offset + main_end_offset)) {
+            /*
+            * NOTE: the stored SSA.rip is the instruction that will be executed upon
+            * ERESUME (i.e., _not_ the one we just measured)
+            */
+            info("^^ enclave prev RIP=%#llx; cur RIP=%#llx; ACCESSED=%d; latency=%d", erip_prev, erip, ACCESSED(*pte_encl),
+                 nemesis_tsc_aex - nemesis_tsc_eresume);
+        }
+
+        erip_prev = erip;
+        irq_cnt++;
+
+        if (do_irq && (irq_cnt > NUM_RUNS * 1000)) {
+            info(
+                "excessive interrupt rate detected (try adjusting timer interval "
+                "to avoid getting stuck in zero-stepping); aborting...");
+            do_irq = 0;
+        }
+
+        /*
+         * NOTE: We explicitly clear the "accessed" bit of the _unprotected_ PTE
+         * referencing the enclave code page about to be executed, so as to be able
+         * to filter out "zero-step" results that won't set the accessed bit.
+         */
+        *pte_encl = MARK_NOT_ACCESSED(*pte_encl);
+
+        /*
+         * Configure APIC timer interval for next interrupt.
+         *
+         * On our evaluation platforms, we explicitly clear the enclave's
+         * _unprotected_ PMD "accessed" bit below, so as to slightly slow down
+         * ERESUME such that the interrupt reliably arrives in the first subsequent
+         * enclave instruction.
+         *
+         */
+        if (do_irq) {
+            *pmd_encl = MARK_NOT_ACCESSED(*pmd_encl);
+            apic_timer_irq(SGX_STEP_TIMER_INTERVAL);
+        }
+
+        return;
+        /* NOTE: somehow calling libc functions here crashes the untrusted runtime... */
+    }
+
+    /* Provoke page fault on enclave entry to initiate single-stepping mode. */
+    void attacker_config_page_table(void)
+    { 
+        code_adrs = (uint64_t*) (bin_offset + main_start_offset);
+        print_page_table( code_adrs );
+        info("enclave trigger code adrs at %p\n", code_adrs);
+
+        ASSERT( pte_encl = remap_page_table_level( code_adrs, PTE) );
+
+        // enable single-stepping
+        #if SINGLE_STEP_ENABLE
+            *pte_encl = MARK_NOT_ACCESSED(*pte_encl);
+            *pte_encl = MARK_EXECUTE_DISABLE(*pte_encl);
+            print_pte(pte_encl);
+            ASSERT( PRESENT(*pte_encl) );
+        #endif
+
+        //print_page_table( get_enclave_base() );
+        ASSERT( pmd_encl = remap_page_table_level( get_enclave_base(), PMD) );
+        ASSERT( PRESENT(*pmd_encl) );
+    }
+
+#endif
+/*****************************************************************************/
+
+
 int ecall_enclave_start(char* libpal_uri, char* args, size_t args_size, char* env,
                         size_t env_size, int parent_stream_fd, sgx_target_info_t* qe_targetinfo,
                         struct pal_topo_info* topo_info, struct pal_dns_host_conf* dns_conf,
@@ -36,13 +215,55 @@ int ecall_enclave_start(char* libpal_uri, char* args, size_t args_size, char* en
         .reserved_mem_ranges_size = reserved_mem_ranges_size,
         .rpc_queue                = g_rpc_queue,
     };
+    
+/*****************************************************************************/
+#if SGX_STEP_ENABLE
+    /* NOTE: set sgx.preheat_enclave = true in manifest to prefault pages (occurs in pal_main.c) */
+    /* Configure and check attacker untrusted runtime environment. */
+    attacker_config_runtime();
+#endif
+/*****************************************************************************/
+    
     return sgx_ecall(ECALL_ENCLAVE_START, &start_args);
 }
 
 int ecall_thread_start(void) {
+/*****************************************************************************/
+#if SGX_STEP_ENABLE
+    thread_ctr++;
+    //info_event("Thread %d started!", thread_ctr);
+
+    if(thread_ctr == 4) {
+
+        spinlock_lock(&g_step_lock);
+        /* 1. Setup attack execution environment. */
+        attacker_config_page_table();
+        register_aep_cb(aep_cb_func);
+
+        info_event("Establishing user-space APIC/IDT mappings");
+        map_idt(&idt);
+
+        install_kernel_irq_handler(&idt, __ss_irq_handler, IRQ_VECTOR);
+        apic_timer_oneshot(IRQ_VECTOR);
+        spinlock_unlock(&g_step_lock);
+        info_event("calling enclave num_runs=%d; TIMER=%d", NUM_RUNS, SGX_STEP_TIMER_INTERVAL);
+        /* 2. Single-step enclaved execution. */
+    }
+#endif
+/*****************************************************************************/
     return sgx_ecall(ECALL_THREAD_START, NULL);
 }
 
 int ecall_thread_reset(void) {
+/*****************************************************************************/
+#if SGX_STEP_ENABLE
+    //info_event("Thread %d stopped!", thread_ctr);
+    if(thread_ctr == THREAD_END){
+        /* 3. Restore normal execution environment. */
+        apic_timer_deadline();
+        info_event("all done; counted %d(+%d ignored)/%d IRQs (AEP/IDT)", irq_cnt, ignored_fault_cnt, __ss_irq_count);
+    }
+#endif
+/*****************************************************************************/
     return sgx_ecall(ECALL_THREAD_RESET, NULL);
 }
